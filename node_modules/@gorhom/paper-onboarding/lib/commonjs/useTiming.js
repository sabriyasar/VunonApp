"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useTiming = void 0;

var _reactNativeReanimated = _interopRequireWildcard(require("react-native-reanimated"));

var _reactNativeGestureHandler = require("react-native-gesture-handler");

var _reactNativeRedash = require("react-native-redash");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

const {
  add,
  or,
  block,
  cond,
  eq,
  set,
  stopClock,
  and,
  not,
  clockRunning,
  startClock,
  lessThan,
  greaterThan,
  interpolate,
  abs,
  timing
} = _reactNativeReanimated.default;

const useTiming = ({
  animatedStaticIndex,
  value,
  velocity,
  state,
  size,
  screenWidth
}) => {
  const clock = (0, _reactNativeRedash.useClock)();
  const config = {
    toValue: (0, _reactNativeRedash.useValue)(0),
    duration: 500,
    easing: _reactNativeReanimated.Easing.out(_reactNativeReanimated.Easing.exp)
  };
  const animationState = {
    finished: (0, _reactNativeRedash.useValue)(0),
    position: (0, _reactNativeRedash.useValue)(0),
    frameTime: (0, _reactNativeRedash.useValue)(0),
    time: (0, _reactNativeRedash.useValue)(0)
  };
  const valueClamp = interpolate(value, {
    inputRange: [screenWidth * -1, 0, screenWidth],
    outputRange: [1, 0, -1],
    extrapolate: _reactNativeReanimated.default.Extrapolate.CLAMP
  });
  const velocityClamp = interpolate(velocity, {
    inputRange: [screenWidth * -2, 0, screenWidth * 2],
    outputRange: [0.5, 0, -0.5],
    extrapolate: _reactNativeReanimated.default.Extrapolate.CLAMP
  });
  const isTimingInterrupted = and(eq(state, _reactNativeGestureHandler.State.BEGAN), clockRunning(clock));
  const finishTiming = [set(animatedStaticIndex, config.toValue), set(animationState.frameTime, 0), set(animationState.time, 0), stopClock(clock)];
  const shouldAnimate = and(not(and(eq(animatedStaticIndex, 0), lessThan(valueClamp, 0))), not(and(eq(animatedStaticIndex, size - 1), greaterThan(valueClamp, 0))));
  const shouldReset = not(greaterThan(add(abs(valueClamp), abs(velocityClamp)), 0.5));
  const shouldAnimateNext = greaterThan(add(animationState.position, velocityClamp), animatedStaticIndex);
  return block([cond(isTimingInterrupted, finishTiming), cond(eq(state, _reactNativeGestureHandler.State.ACTIVE), cond(and(not(and(eq(animatedStaticIndex, 0), lessThan(valueClamp, 0))), not(and(eq(animatedStaticIndex, size - 1), greaterThan(valueClamp, 0)))), [set(animationState.finished, 0), set(animationState.position, add(animatedStaticIndex, valueClamp))])), cond(eq(state, _reactNativeGestureHandler.State.END), [cond(and(not(clockRunning(clock)), not(animationState.finished)), [cond(or(shouldReset, not(shouldAnimate)), set(config.toValue, animatedStaticIndex), cond(shouldAnimateNext, set(config.toValue, add(animatedStaticIndex, 1)), set(config.toValue, (0, _reactNativeReanimated.sub)(animatedStaticIndex, 1)))), set(animationState.finished, 0), set(animationState.frameTime, 0), set(animationState.time, 0), startClock(clock)]), timing(clock, animationState, config), cond(animationState.finished, finishTiming)]), animationState.position]);
};

exports.useTiming = useTiming;
//# sourceMappingURL=useTiming.js.map