"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _reactNative = require("react-native");

var _reactNativeRedash = require("react-native-redash");

var _reactNativeGestureHandler = require("react-native-gesture-handler");

var _reactNativeReanimated = _interopRequireDefault(require("react-native-reanimated"));

var _lodash = _interopRequireDefault(require("lodash.isequal"));

var _background = _interopRequireDefault(require("./components/background"));

var _page = _interopRequireDefault(require("./components/page"));

var _indicatorsContainer = _interopRequireDefault(require("./components/indicatorsContainer"));

var _closeButton = _interopRequireDefault(require("./components/closeButton"));

var _useTiming = require("./useTiming");

var _constants = require("./constants");

var _styles = require("./styles");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function _getRequireWildcardCache() { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// @ts-ignore ðŸ˜ž
// @ts-ignore
_reactNativeReanimated.default.addWhitelistedUIProps({
  cx: true,
  cy: true,
  r: true,
  fillOpacity: true,
  pointerEvents: true
});

const {
  interpolate,
  add,
  useCode,
  onChange,
  call
} = _reactNativeReanimated.default;

const PaperOnboardingComponent = ({
  data,
  safeInsets: _safeInsets,
  direction = _constants.DEFAULT_DIRECTION,
  // indicator config
  indicatorSize = _constants.DEFAULT_INDICATOR_SIZE,
  indicatorBackgroundColor = _constants.DEFAULT_INDICATOR_BACKGROUND_COLOR,
  indicatorBorderColor = _constants.DEFAULT_INDICATOR_BORDER_COLOR,
  // override styles
  titleStyle,
  descriptionStyle,
  // close button config
  closeButton,
  closeButtonTextStyle,
  closeButtonText = _constants.DEFAULT_CLOSE_BUTTON_TEXT,
  onCloseButtonPress = _constants.DEFAULT_CLOSE_BUTTON_CALLBACK,
  onIndexChange
}) => {
  // state
  const [dimensions, setDimensions] = (0, _react.useState)({
    width: _reactNative.Dimensions.get('window').width,
    height: _reactNative.Dimensions.get('window').height
  }); // refs

  const pagesRef = (0, _react.useRef)(data.map(() => null)); //#region variables

  const safeInsets = (0, _react.useMemo)(() => {
    var _safeInsets$top, _safeInsets$bottom, _safeInsets$left, _safeInsets$right;

    return {
      top: (_safeInsets$top = _safeInsets === null || _safeInsets === void 0 ? void 0 : _safeInsets.top) !== null && _safeInsets$top !== void 0 ? _safeInsets$top : _constants.DEFAULT_SAFE_INSET,
      bottom: (_safeInsets$bottom = _safeInsets === null || _safeInsets === void 0 ? void 0 : _safeInsets.bottom) !== null && _safeInsets$bottom !== void 0 ? _safeInsets$bottom : _constants.DEFAULT_SAFE_INSET,
      left: (_safeInsets$left = _safeInsets === null || _safeInsets === void 0 ? void 0 : _safeInsets.left) !== null && _safeInsets$left !== void 0 ? _safeInsets$left : _constants.DEFAULT_SAFE_INSET,
      right: (_safeInsets$right = _safeInsets === null || _safeInsets === void 0 ? void 0 : _safeInsets.right) !== null && _safeInsets$right !== void 0 ? _safeInsets$right : _constants.DEFAULT_SAFE_INSET
    }; // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [_safeInsets]); //#endregion
  // memo

  const {
    gestureHandler,
    state,
    translation,
    velocity
  } = (0, _reactNativeRedash.usePanGestureHandler)();
  const indicatorsContainerLeftPadding = (0, _react.useMemo)(() => dimensions.width / 2 - indicatorSize / 2, [dimensions.width, indicatorSize]); // animations

  const animatedStaticIndex = (0, _reactNativeRedash.useValue)(0);
  const animatedIndex = (0, _useTiming.useTiming)({
    animatedStaticIndex,
    value: direction === 'horizontal' ? translation.x : translation.y,
    velocity: direction === 'horizontal' ? velocity.x : velocity.y,
    state: state,
    size: data.length,
    screenWidth: dimensions.width
  });
  const animatedIndicatorsContainerPosition = add(interpolate(animatedIndex, {
    inputRange: data.map((_, index) => index),
    outputRange: data.map((_, index) => index * indicatorSize * -1),
    extrapolate: _reactNativeReanimated.default.Extrapolate.CLAMP
  }), indicatorsContainerLeftPadding); // callbacks

  const handlePageRef = (0, _react.useCallback)((ref, index) => {
    pagesRef.current[index] = ref;
  }, []);
  const handleOnLayout = (0, _react.useCallback)(({
    nativeEvent: {
      layout: {
        width,
        height
      }
    }
  }) => {
    setDimensions({
      width,
      height
    });
  }, []); //#region effects

  useCode(() => onChange(animatedStaticIndex, call([animatedStaticIndex], args => {
    /**
     * @DEV
     * here we directly manipulate pages native props by setting `pointerEvents`
     * to `auto` for current page and `none` for others.
     */
    pagesRef.current.map((pageRef, _index) => {
      // @ts-ignore
      pageRef.setNativeProps({
        pointerEvents: _index === args[0] ? 'auto' : 'none'
      });
    });

    if (onIndexChange) {
      onIndexChange(args[0]);
    }
  })), []); //#endregion
  // renders

  return /*#__PURE__*/_react.default.createElement(_reactNativeGestureHandler.PanGestureHandler, gestureHandler, /*#__PURE__*/_react.default.createElement(_reactNativeReanimated.default.View, {
    onLayout: handleOnLayout,
    style: _styles.styles.container
  }, /*#__PURE__*/_react.default.createElement(_background.default, {
    animatedIndex: animatedIndex,
    data: data,
    safeInsets: safeInsets,
    screenDimensions: dimensions,
    indicatorSize: indicatorSize,
    animatedIndicatorsContainerPosition: animatedIndicatorsContainerPosition
  }), data.map((item, index) => /*#__PURE__*/_react.default.createElement(_page.default, {
    key: "page-".concat(index),
    index: index,
    item: item,
    animatedIndex: animatedIndex,
    indicatorSize: indicatorSize,
    titleStyle: titleStyle,
    descriptionStyle: descriptionStyle,
    safeInsets: safeInsets,
    screenDimensions: dimensions,
    handleRef: handlePageRef
  })), /*#__PURE__*/_react.default.createElement(_indicatorsContainer.default, {
    data: data,
    animatedIndex: animatedIndex,
    animatedIndicatorsContainerPosition: animatedIndicatorsContainerPosition,
    indicatorSize: indicatorSize,
    indicatorBackgroundColor: indicatorBackgroundColor,
    indicatorBorderColor: indicatorBorderColor,
    safeInsets: safeInsets
  }), /*#__PURE__*/_react.default.createElement(_closeButton.default, {
    data: data,
    animatedIndex: animatedIndex,
    safeInsets: safeInsets,
    closeButtonText: closeButtonText,
    closeButtonTextStyle: closeButtonTextStyle,
    closeButton: closeButton,
    onCloseButtonPress: onCloseButtonPress
  })));
};

const PaperOnboarding = /*#__PURE__*/(0, _react.memo)(PaperOnboardingComponent, _lodash.default);
var _default = PaperOnboarding;
exports.default = _default;
//# sourceMappingURL=PaperOnboarding.js.map